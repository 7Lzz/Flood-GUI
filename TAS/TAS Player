getgenv().Mirrored = false
local LocalPlayer = game.Players.LocalPlayer
local character = LocalPlayer.Character
local HumanoidRootPart = character.HumanoidRootPart
local Multiplayer = Workspace.Multiplayer
local RunService = game:GetService('RunService')
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local wait = task.wait

local CLMAIN = getsenv(LocalPlayer.PlayerScripts.CL_MAIN_GameScript) -- FE2 Notifications
local newAlert = CLMAIN.newAlert

if not Ran then
    newAlert("TAS Player v1.3.0 Started.",Color3.new(0,1,0))
else
    newAlert("Ready for next map",Color3.new(0,1,0.5))
end
getgenv().Ran = true

local Animate = getsenv(character.Animate)
local RunName = Multiplayer:WaitForChild('NewMap'):WaitForChild('Settings'):WaitForChild('MapName').Value
local TAS
if isfile(RunName .. ".json") then
    TAS = game:GetService("HttpService"):JSONDecode(readfile(RunName .. ".json"))
else
    newAlert(RunName .. ".json".." Does not exist!", Color3.new(1,0,0))
    warn(RunName .. ".json".." Does not exist!")
end

newAlert("TAS Loaded!")
local Map = Multiplayer:WaitForChild("NewMap")
Map:GetPropertyChangedSignal("Name"):Wait()

if Map:WaitForChild('Settings'):FindFirstChild("_MirrorMap") then
	newAlert('Map is not Mirrored.')
	Mirrored = false
else
	newAlert('Map is mirrored, TAS will be played mirrored!')
	Mirrored = true
end
ReplicatedStorage.Remote.StartClientMapTimer.OnClientEvent:Wait()
local Spawn = (function() -- this whole function was made by Epix
	local characterPosition = HumanoidRootPart.Position
	local dummyPart = Instance.new("Part")
	dummyPart.Size = Vector3.one
	dummyPart.Position = characterPosition - (Vector3.yAxis * 2)
	dummyPart.Anchored = true
	dummyPart.CanCollide = false
	dummyPart.Parent = Workspace
	local overlapParams = OverlapParams.new()
	overlapParams.FilterDescendantsInstances = {
		dummyPart
	}
	overlapParams.FilterType = Enum.RaycastFilterType.Whitelist
	local spawnCandidates = table.create(10)
	for _, item in next, Map:GetDescendants() do
		if not item:IsA("BasePart") or (item.Position - characterPosition).Magnitude > 10 then
			continue
		end
		local facingUpVector
		if item.CFrame.UpVector:Dot(Vector3.yAxis) >= 0 then
			facingUpVector = item.CFrame.UpVector
		else
			facingUpVector = -item.CFrame.UpVector
		end
		local candidatesInArea = Workspace:GetPartBoundsInBox(
                item.CFrame + (facingUpVector * (item.Size.Y / 2 + 0.25)),
                Vector3.new(item.Size.X, 0.5, item.Size.Z),
                overlapParams
            )
		for _, candidate in next, candidatesInArea do
			if candidate == dummyPart then
				table.insert(spawnCandidates, item)
			end
		end
	end
	dummyPart:Destroy()
	if #spawnCandidates >= 1 then
		for _, spawnCandidate in next, spawnCandidates do
			if (spawnCandidate.Transparency >= 0.8 or spawnCandidate.Parent == map) then
				return spawnCandidate
			end
		end
		for _, spawnCandidate in next, spawnCandidates do
			if spawnCandidate.CanCollide then
				return spawnCandidate
			end
		end
		return spawnCandidates[1]
	else
	            local CharacterParts = {}
		    local Character = character
		    local Ray = Ray.new(Character.HumanoidRootPart.Position + Vector3.one,Vector3.new(0,-20,0))
		    if game.Workspace.CurrentCamera:FindFirstChild("ShadowPt") then
		        table.insert(CharacterParts,game.Workspace.CurrentCamera.ShadowPt)
		    end
		    for i,v in pairs(game.Players:GetPlayers()) do
		        pcall(function()
		            for j,k in pairs(v.Character:GetChildren()) do
		                if k:IsA("Part") then
		                    table.insert(CharacterParts,k)
		                end
		            end
		        end) 
		    end
		    while true do
		        local hit,pos = game.Workspace:FindPartOnRayWithIgnoreList(Ray,CharacterParts)
		        if hit and hit:IsA("Part") and math.floor(hit.Size.X) == math.floor(hit.Size.Z) then
		            return hit
		        elseif hit then
		            table.insert(CharacterParts,hit)
		        end
		    end
	end
end)()

local TimeStart = os.clock()
newAlert('TAS Running..')
PlayAnim = Animate.playAnimation
Animate.playAnimation = function()
end

for _, v in next, Map:GetDescendants() do
	if v.Name == 'ButtonIcon' then
		local buttonPart = v.Parent.Parent:FindFirstChildOfClass('Part')
		if buttonPart ~= nil then
			buttonPart.Size = Vector3.new(6, 6, 6)
		end
	end
end

local Offset = Spawn.Position - Vector3.new(0, 1000, 0)
local DiffAnim = 0
local OldFrame = 3

local DiffFormat = TAS[4].CFrame ~= nil

local Loop
local Death
Death = character.Humanoid.Died:Connect(function(Change)
    Death:Disconnect()
	Loop:Disconnect()
	Animate.playAnimation = PlayAnim
	newAlert('Player Died.', Color3.new(1, 0, 0))
end)
Loop = RunService.Heartbeat:connect(function(DeltaTime)
	local NewFrame = #TAS
	local Divider = OldFrame + 60
	if Divider < NewFrame then
		NewFrame = Divider
	end
	local Time
	for i = OldFrame, NewFrame do
		if TAS[i].time ~= nil then
		    Time = TAS[i].time
		else
		    Time = TAS[i].Time
		end
		if (os.clock() - TimeStart) < Time then
			continue
		elseif i >= #TAS then
			Death:Disconnect()
			Loop:Disconnect()
			Animate.playAnimation = PlayAnim
			newAlert('TAS Run Finished!', Color3.new(0, 1, 0))
			newAlert('TAS Player By Tomato', Color3.new(0, 1, 0))
		elseif (os.clock() - TimeStart) >= Time then
			OldFrame = i
            local CCFrame, CCameraCFrame, VVelocity, AAnimation
            if not DiffFormat then
			    CCFrame = TAS[i].CCFrame
			    CCameraCFrame = TAS[i].CCameraCFrame
			    VVelocity = TAS[i].VVelocity
			    AAnimation = TAS[i].AAnimation
            else
                CCFrame = TAS[i].CFrame
                CCameraCFrame = TAS[i].CameraCFrame
                VVelocity = TAS[i].Velocity
                AAnimation = TAS[i].Animation
            end
			if Mirrored == true then
				CCFrame[3] = -CCFrame[3]
				CCFrame[6] = -CCFrame[5]
				VVelocity[1] = -VVelocity[1]
                VVelocity[3] = -VVelocity[3]
				CCameraCFrame[3] = CCameraCFrame[3]
				CCameraCFrame[6] = CCameraCFrame[6]
			end
			HumanoidRootPart.CFrame = CFrame.new(CCFrame[1], CCFrame[2], CCFrame[3]) * CFrame.fromEulerAnglesXYZ(CCFrame[4], CCFrame[5], CCFrame[6]) + Offset
			HumanoidRootPart.Velocity = Vector3.new(VVelocity[1], VVelocity[2], VVelocity[3])
			Workspace.CurrentCamera.CFrame = CFrame.new(CCameraCFrame[1], CCameraCFrame[2], CCameraCFrame[3]) * CFrame.fromEulerAnglesXYZ(CCameraCFrame[4], CCameraCFrame[5], CCameraCFrame[6]) + Offset
			if 1 == 1 then -- TAS[i].AAnimationChanged > DiffAnim
				if AAnimation[1] == "walk" then
					PlayAnim(AAnimation[1], AAnimation[2], character.Humanoid)
					DiffAnim = TAS[i].AAnimationChanged
					Animate.setAnimationSpeed(0.76)
				elseif AAnimation[1] == "climb" then
				else
					PlayAnim(AAnimation[1], AAnimation[2], character.Humanoid)
					DiffAnim = TAS[i].AAnimationChanged
				end
			end
		end
	end
end)
