--[[
Reconstructed FE2 Animate Script
Based on analysis of Default Roblox Animate Script and FE2 Decompiled Animate Script.
Note: This script assumes the presence of specific children and values within the character
and ReplicatedStorage as seen in the decompiled script (e.g., AnimIDs, various BindableEvents).
--]]

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-- Instances
local Character = ... -- Loadstring Call must supply Character reference.
if not Character then
	warn("Loadstring did not supply Character or nil.")
end
local AnimateScript = Character.Animate
-- Remove Old Animate Connections.
local AnimateClone = AnimateScript:Clone()
AnimateScript:Destroy()
AnimateClone.Parent = Character

local Humanoid = Character:WaitForChild("Humanoid")
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
local Torso = Character:WaitForChild("Torso")

-- Motor6Ds
local RightShoulder = Torso:WaitForChild("Right Shoulder")
local LeftShoulder = Torso:WaitForChild("Left Shoulder")
local RightHip = Torso:WaitForChild("Right Hip")
local LeftHip = Torso:WaitForChild("Left Hip")
local Neck = Torso:WaitForChild("Neck") -- Referenced in default, ensure it exists [cite: 1]

-- Animation References [cite: 15]
local AnimIDs = ReplicatedStorage:WaitForChild("Animations"):WaitForChild("AnimIDs")

-- AnimateScript Children (Events/Values)
local ToggleSwimEvent = AnimateScript:WaitForChild("ToggleSwim")
local SlidingEvent = AnimateScript:WaitForChild("Sliding")
local AirDivingEvent = AnimateScript:WaitForChild("AirDiving")
local WalljumpEvent = AnimateScript:WaitForChild("Walljump")
local SwingingEvent = AnimateScript:WaitForChild("Swinging")
local UpdateEmoteEvent = AnimateScript:WaitForChild("UpdEmote")
local UpdateAnimationsEvent = AnimateScript:WaitForChild("UpdAnimations")
local EmoteFireEvent = AnimateScript:WaitForChild("EmoteFire")
local PlayEmoteFunction = AnimateScript:WaitForChild("PlayEmote") -- From default script, FE2 might use a different system

-- State Variables
local pose = "Standing"
local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0
local animTable = {}

local toolAnim = "None"
local toolAnimTime = 0
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

local jumpAnimTime = 0
local JUMP_ANIM_DURATION = 0.3 -- [cite: 61]

local isSwimming = false --
local isSliding = false -- [cite: 88]
local isWallHanging = false --
local isSwinging = false --
local isAirDiving = false -- Helper state, implied by AirDivingEvent

local lastEmoteTime = tick() - 3 -- [cite: 15]
local swimVelocityInstance = nil -- [cite: 16]
local swimAngleTracks = {} -- [cite: 83]

-- Constants
local EMOTE_TRANSITION_TIME = 0.1
local TOOL_TRANSITION_TIME = 0.1
local FALL_TRANSITION_TIME = 0.3

-- Animation Definitions (Merging default and FE2 decompiled) [cite: 1-4, 16-32]
local animNames = {
	idle = {
		{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
		{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
	},
	walk = {
		{ id = "http://www.roblox.com/asset/?id=" .. AnimIDs.Walk.Value, weight = 10 } --
	},
	run = { -- Default has run.xml, FE2 uses walk logic primarily [cite: 1-2, 18]
		{ id = "http://www.roblox.com/asset/?id=" .. AnimIDs.Walk.Value, weight = 10 } -- Using Walk for Run as FE2 seems to adjust speed
	},
	jump = {
		{ id = "http://www.roblox.com/asset/?id=" .. AnimIDs.Jump.Value, weight = 10 } --
	},
	fall = {
		{ id = "http://www.roblox.com/asset/?id=" .. AnimIDs.Fall.Value, weight = 10 } -- [cite: 19]
	},
	climb = {
		{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } --(Default ID)
	},
	sit = {
		{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } -- [cite: 21] (Default ID)
	},
	swimidle = { --
		{ id = "http://www.roblox.com/asset/?id=" .. AnimIDs.SwimIdle.Value, weight = 10 }
	},
	swim = { -- [cite: 20]
		{ id = "http://www.roblox.com/asset/?id=" .. AnimIDs.Swim.Value, weight = 10 }
	},
	slide = { --
		{ id = "http://www.roblox.com/asset/?id=" .. AnimIDs.Slide.Value, weight = 10 }
	},
	airdive = { --
		{ id = "http://www.roblox.com/asset/?id=" .. AnimIDs.AirDive.Value, weight = 10 }
	},
	swing = { -- [cite: 23]
		{ id = "http://www.roblox.com/asset/?id=" .. AnimIDs.Swing.Value, weight = 10 }
	},
	wallhang = { --
		{ id = "http://www.roblox.com/asset/?id=" .. AnimIDs.WallHang.Value, weight = 10 }
	},
	toolnone = { -- [cite: 24] (FE2 uses a different ID than default)
		{ id = "http://www.roblox.com/asset/?id=14350782140", weight = 10 } -- Default: 182393478 [cite: 2]
	},
	toolslash = { --(Default ID)
		{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 }
	},
	toollunge = { -- [cite: 25] (Default ID)
		{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 }
	},
	wave = { --(Default ID)
		{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 }
	},
	point = { -- [cite: 26] (Default ID)
		{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 }
	},
	dance1 = { --(Default IDs)
		{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 },
		{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 },
		{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 }
	},
	dance2 = { --(Default IDs)
		{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 },
		{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 },
		{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 }
	},
	dance3 = { --(Default IDs)
		{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 },
		{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 },
		{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 }
	},
	laugh = { -- [cite: 31] (Default ID)
		{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 }
	},
	cheer = { --(Default ID)
		{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 }
	},
	customemote = { -- [cite: 32]
		{ id = "http://www.roblox.com/asset/?id=" .. AnimIDs.Emote.Value, weight = 10 }
	}
}

local dances = {"dance1", "dance2", "dance3"} -- [cite: 4, 43]
local emoteNames = { -- [cite: 4, 43]
	wave = false, point = false, dance1 = true, dance2 = true, dance3 = true,
	laugh = false, cheer = false, customemote = false -- Added customemote
}

--[[ Functions --]]

-- Function to handle loading/reloading animation sets [cite: 4-6, 32-43]
function configureAnimationSet(name, fileList)
	if animTable[name] then
		for _, connection in pairs(animTable[name].connections) do
			connection:Disconnect()
		end
	end
	animTable[name] = { count = 0, totalWeight = 0, connections = {} }

	local configFolder = AnimateScript:FindFirstChild(name)
	if configFolder then
		-- Connect signals for dynamic updates
		table.insert(animTable[name].connections, configFolder.ChildAdded:Connect(function(child)
			if child:IsA("Animation") then configureAnimationSet(name, fileList) end
		end)) --
		table.insert(animTable[name].connections, configFolder.ChildRemoved:Connect(function(child)
			if child:IsA("Animation") then configureAnimationSet(name, fileList) end
		end)) --

		local index = 1
		for _, child in ipairs(configFolder:GetChildren()) do
			if child:IsA("Animation") then
				table.insert(animTable[name].connections, child.Changed:Connect(function(property)
					configureAnimationSet(name, fileList) -- Reconfigure on property change
				end)) --

				animTable[name][index] = {}
				animTable[name][index].anim = child
				local weightObj = child:FindFirstChild("Weight")
				animTable[name][index].weight = (weightObj and weightObj:IsA("NumberValue")) and weightObj.Value or 1 --
				animTable[name].count += 1
				animTable[name].totalWeight += animTable[name][index].weight
				index += 1
			end
		end
	end

	-- Fallback to defaults if no overrides or overrides are invalid
	if animTable[name].count == 0 then
		animTable[name].totalWeight = 0 -- Reset weight for default calculation
		for index, animData in ipairs(fileList) do
			animTable[name][index] = {}
			local animInstance = Instance.new("Animation")
			animInstance.Name = name
			animInstance.AnimationId = animData.id
			animTable[name][index].anim = animInstance
			animTable[name][index].weight = animData.weight
			animTable[name].count += 1
			animTable[name].totalWeight += animData.weight
		end
	end
end

-- Function to stop all non-tool animations [cite: 6-7, 44-45]
function stopAllAnimations()
	local returnPose = pose
	if emoteNames[currentAnim] == false then
		returnPose = "idle" -- Return to idle after non-looping emote
	end

	currentAnim = ""
	currentAnimInstance = nil
	if currentAnimKeyframeHandler then
		currentAnimKeyframeHandler:Disconnect()
		currentAnimKeyframeHandler = nil
	end
	if currentAnimTrack then
		currentAnimTrack:Stop(0.1) -- Smooth transition out
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end
	return returnPose
end

-- Function to adjust animation speed [cite: 7, 45-46]
function setAnimationSpeed(speed)
	speed = math.max(speed, 0.01) -- Prevent zero or negative speed
	if currentAnimTrack and speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(currentAnimSpeed)
	end
end

-- Keyframe handler for looping/chaining animations [cite: 7, 46-47]
function keyFrameReachedFunc(frameName)
	if frameName == "End" then
		local repeatAnim = currentAnim
		local isEmote = emoteNames[repeatAnim]
		if isEmote == false then -- Non-looping emote ends
			repeatAnim = "idle"
		elseif isEmote == nil and pose == "Standing" then -- If not an emote and standing, default to idle
			repeatAnim = "idle"
		elseif isEmote == nil and pose ~= "Standing" then -- If not an emote and not standing, let state machine handle it
			return -- Don't automatically loop things like jump/fall
		end

		local speed = currentAnimSpeed
		playAnimation(repeatAnim, 0.0, Humanoid) -- Play next anim immediately
		setAnimationSpeed(speed) -- Restore speed if needed
	end
end

-- Function to play a main animation [cite: 7-9, 47-52]
function playAnimation(animName, transitionTime, humanoidRef)
	if not animTable[animName] or animTable[animName].count == 0 then
		-- warn("Animation set not found or empty:", animName)
		return
	end

	-- FE2 specific checks for mutually exclusive states
	if isSliding and animName ~= "slide" then return end
	if isSwinging and animName ~= "swing" then return end
	if isWallHanging and animName ~= "wallhang" then return end
	if isAirDiving and animName ~= "airdive" then return end -- Assuming AirDive has priority

	local animSet = animTable[animName]
	local roll = math.random(1, animSet.totalWeight)
	local index = 1
	while roll > animSet[index].weight do --
		roll = roll - animSet[index].weight
		index = index + 1
	end
	local selectedAnim = animSet[index].anim

	if selectedAnim ~= currentAnimInstance or animName ~= currentAnim then
		if currentAnimTrack then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		currentAnimSpeed = 1.0 -- Reset speed for new animation

		currentAnimTrack = humanoidRef:LoadAnimation(selectedAnim) -- [cite: 9, 51]
		-- Determine priority (example, adjust as needed)
		if emoteNames[animName] ~= nil then
			currentAnimTrack.Priority = Enum.AnimationPriority.Action
		elseif animName == "jump" or animName == "fall" or animName == "airdive" then
			currentAnimTrack.Priority = Enum.AnimationPriority.Action
		elseif animName == "slide" or animName == "swing" or animName == "wallhang" then
			currentAnimTrack.Priority = Enum.AnimationPriority.Action
		elseif animName == "walk" or animName == "run" or animName == "swim" then
			currentAnimTrack.Priority = Enum.AnimationPriority.Movement
		elseif animName == "climb" then
			currentAnimTrack.Priority = Enum.AnimationPriority.Movement
		else -- Idle, Sit, SwimIdle etc.
			currentAnimTrack.Priority = Enum.AnimationPriority.Idle
		end

		currentAnimTrack:Play(transitionTime) -- [cite: 9, 51]

		currentAnim = animName
		currentAnimInstance = selectedAnim

		if currentAnimKeyframeHandler then
			currentAnimKeyframeHandler:Disconnect() -- [cite: 52]
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:Connect(keyFrameReachedFunc) -- [cite: 9, 52]
	end
end

-- Tool animation keyframe handler [cite: 9, 52-53]
function toolKeyFrameReachedFunc(frameName)
	if frameName == "End" then
		-- Only loop toolnone animation
		if toolAnim == "toolnone" then
			playToolAnimation(toolAnim, 0.0, Humanoid, Enum.AnimationPriority.Idle) -- [cite: 53]
		else
			-- For slash/lunge, transition back to none after ending
			toolAnim = "None"
			animateTool() -- Play the toolnone anim
		end
	end
end

-- Function to play tool animations [cite: 9-10, 53-55]
function playToolAnimation(animName, transitionTime, humanoidRef, priority)
	priority = priority or Enum.AnimationPriority.Action -- Default priority

	if not animTable[animName] or animTable[animName].count == 0 then
		-- warn("Tool animation set not found or empty:", animName)
		return
	end

	local animSet = animTable[animName]
	local roll = math.random(1, animSet.totalWeight)
	local index = 1
	while roll > animSet[index].weight do -- [cite: 54]
		roll = roll - animSet[index].weight
		index = index + 1
	end
	local selectedAnim = animSet[index].anim

	if selectedAnim ~= toolAnimInstance then
		if toolAnimTrack then
			toolAnimTrack:Stop(transitionTime)
			toolAnimTrack:Destroy()
			-- transitionTime = 0 -- FE2 forces immediate transition
		end

		toolAnimTrack = humanoidRef:LoadAnimation(selectedAnim) -- [cite: 10, 55]
		toolAnimTrack.Priority = priority -- Apply priority
		toolAnimTrack:Play(transitionTime) -- [cite: 10, 55]

		toolAnim = animName
		toolAnimInstance = selectedAnim

		if currentToolAnimKeyframeHandler then
			currentToolAnimKeyframeHandler:Disconnect()
		end
		currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:Connect(toolKeyFrameReachedFunc) -- [cite: 10, 55]
	end
end

-- Function to stop tool animations [cite: 10, 55-57]
function stopToolAnimations()
	if currentToolAnimKeyframeHandler then
		currentToolAnimKeyframeHandler:Disconnect()
		currentToolAnimKeyframeHandler = nil
	end

	toolAnim = "None" -- Should naturally transition via animateTool()
	toolAnimInstance = nil
	if toolAnimTrack then
		toolAnimTrack:Stop(0.1) -- Smooth transition out
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end
end

-- Update swim angle animations based on velocity
function updateSwimDir()
	-- Stop all angle animations first
	for _, track in ipairs(swimAngleTracks) do
		if track.IsPlaying then
			track:Stop(0.1)
		end
	end

	if isSwimming and swimVelocityInstance then
		local angleIndex = 0
		local moveDir = Humanoid.MoveDirection
		local swimVelY = swimVelocityInstance.Velocity.Y

		if moveDir.Magnitude < 0.1 then -- Primarily vertical movement
			if swimVelY < -0.1 then angleIndex = 1 -- Down (90)
			elseif swimVelY > 0.1 then angleIndex = 5 -- Up (-90)
			else angleIndex = 3 -- Neutral (0) - if barely moving
			end
		else -- Horizontal movement involved
			angleIndex = 3 -- Start with neutral (0)
			if swimVelY < -0.1 then angleIndex = angleIndex - 1 -- Adjust for down (-45)
			elseif swimVelY > 0.1 then angleIndex = angleIndex + 1 -- Adjust for up (45)
			end
			-- Clamp index [cite: 86]
			angleIndex = math.clamp(angleIndex, 1, 5)
		end

		if angleIndex > 0 and swimAngleTracks[angleIndex] then
			-- Play the target angle animation, adjust weight/fade time maybe?
			-- FE2 just plays it directly [cite: 86]
			if not swimAngleTracks[angleIndex].IsPlaying then
				swimAngleTracks[angleIndex]:Play(0.1, 1, 1) -- Blend in, full weight, normal speed
			end
		end
	end
end

-- Get currently equipped tool [cite: 11, 65-66]
function getTool()
	for _, child in ipairs(Character:GetChildren()) do
		if child:IsA("Tool") then return child end
	end
	return nil
end

-- Get tool animation trigger value [cite: 11, 66-67]
function getToolAnim(tool)
	local animString = tool:FindFirstChild("toolanim")
	if animString and animString:IsA("StringValue") then
		return animString
	end
	return nil
end

-- Handle tool animation logic [cite: 12-13, 67-68, 77-79]
function animateTool()
	local tool = getTool()
	if tool and tool:FindFirstChild("Handle") then
		local animStringValue = getToolAnim(tool)
		if animStringValue then
			toolAnim = animStringValue.Value -- Read the desired animation
			animStringValue:Destroy() -- Consume the trigger
			toolAnimTime = tick() + 0.3 -- Duration for action anims like Slash/Lunge? [cite: 78]
		end

		-- Check if timed animation expired
		if toolAnim ~= "None" and toolAnim ~= "toolnone" and tick() > toolAnimTime then
			toolAnim = "None"
			toolAnimTime = 0
		end

		-- Play the determined animation
		if toolAnim == "Slash" then
			playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action) --
		elseif toolAnim == "Lunge" then
			playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action) -- [cite: 68]
		else -- Default to "toolnone" if equipped
			playToolAnimation("toolnone", TOOL_TRANSITION_TIME, Humanoid, Enum.AnimationPriority.Idle) -- [cite: 67]
		end
	else
		-- No tool equipped, stop animations
		if toolAnim ~= "None" or toolAnimInstance ~= nil then
			stopToolAnimations()
			toolAnim = "None"
			toolAnimInstance = nil
			toolAnimTime = 0
		end
	end
end

-- Perform emote logic
function performEmote(emoteName, isChatCommand)
	-- FE2 checks: not swimming, standing pose, cooldown for custom emote [cite: 80]
	if not isSwimming and pose == "Standing" and emoteName then
		if emoteNames[emoteName] ~= nil then -- Check if it's a known emote
			local canPlay = true
			if emoteName == "customemote" and not isChatCommand then -- Check cooldown only for button press
				if tick() < lastEmoteTime + 3 then -- [cite: 80]
					canPlay = false
				else
					lastEmoteTime = tick() -- [cite: 81]
					-- Play sound if exists [cite: 81]
					local emoteSound = Character.Head:FindFirstChild("Emote")
					if emoteSound and emoteSound:IsA("Sound") and emoteSound.SoundId ~= "" then
						emoteSound:Play()
					end
				end
			end

			if canPlay then
				playAnimation(emoteName, EMOTE_TRANSITION_TIME, Humanoid)
				return true -- Indicate success
			end
		end
	end
	return false -- Indicate failure
end


--[[ Humanoid State Handlers --]]

function onRunning(speed)
	-- print("Running Speed:", speed)
	if isSwimming or isSliding or isSwinging or isWallHanging then return end -- Don't run if doing other actions

	if speed > 0.1 then -- Threshold to differentiate from idle drift
		if pose ~= "Running" then
			playAnimation("walk", 0.1, Humanoid) -- Use walk anim [cite: 59]
		end
		-- FE2 adjusts speed based on walk animation ID
		-- Assuming the loaded walk animation ID matches AnimIDs.Walk.Value
		local baseSpeed = 14.5 -- Default R15 walk speed scalar? FE2 uses 14.5 or 26 [cite: 59, 75]
		-- Check if the specific default walk anim is playing (less reliable if customized)
		if currentAnimInstance and string.match(currentAnimInstance.AnimationId, "180426354") then -- Default walk anim ID
			baseSpeed = 14.5 -- Matches default script scalar [cite: 10]
		elseif currentAnimInstance and string.match(currentAnimInstance.AnimationId, tostring(AnimIDs.Walk.Value)) then
			-- Use FE2's logic if its walk anim is playing
			-- FE2 seems to use 14.5 for its default, and 26 for another case? Let's stick to 14.5 or adjust based on observation.
			baseSpeed = 14.5 -- Or 26 based on the FE2 logic [cite: 59, 75] - Needs testing
		end
		setAnimationSpeed(speed / baseSpeed)
		pose = "Running"
	else
		if pose == "Running" then -- Only switch to idle if actively stopping from running
			-- Don't interrupt emotes [cite: 10]
			if emoteNames[currentAnim] == nil then
				playAnimation("idle", 0.2, Humanoid) -- Smoother transition to idle
				pose = "Standing"
			end
		end
	end
end

function onDied()
	stopAllAnimations()
	stopToolAnimations()
	pose = "Dead"
	-- Disable further state changes maybe?
end

function onJumping()
	if isSwimming or isSliding or isSwinging or isWallHanging then return end -- Don't jump if doing other actions
	-- print("Jumping")
	playAnimation("jump", 0.1, Humanoid) --
	jumpAnimTime = JUMP_ANIM_DURATION -- [cite: 61]
	pose = "Jumping"
	-- FE2 Buddy jump signal [cite: 61]
	-- local buddyInstance = Character:FindFirstChild("Buddy")
	-- if buddyInstance and buddyInstance:FindFirstChild("Follow") and buddyInstance.Follow:FindFirstChild("Jump") then
	-- 	buddyInstance.Follow.Jump:FireServer()
	-- end
end

function onClimbing(speed)
	if isSwimming then return end -- Swimming takes priority
	-- print("Climbing Speed:", speed)
	playAnimation("climb", 0.1, Humanoid) --
	setAnimationSpeed(speed / 12.0) -- [cite: 62] (Default scalar)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
	-- Might need to play an animation here if desired
	playAnimation("idle", 0.1, Humanoid) -- Transition to idle after getting up
	pose = "Standing" -- Immediately go to standing
end

function onFreeFall()
	if pose == "Dead" then return end
	if isSliding or isSwinging or isWallHanging then return end -- These states override falling animation

	if isSwimming then -- Handle swimming logic separately [cite: 63]
		local moveDir = Humanoid.MoveDirection
		local swimVelY = swimVelocityInstance and swimVelocityInstance.Velocity.Y or 0
		if moveDir.Magnitude < 0.1 and math.abs(swimVelY) < 0.1 then -- [cite: 63]
			if pose ~= "SwimIdle" then playAnimation("swimidle", 0.1, Humanoid) end
			pose = "SwimIdle"
		else
			if pose ~= "Swimming" then playAnimation("swim", 0.1, Humanoid) end -- [cite: 63]
			pose = "Swimming"
		end
		updateSwimDir() -- Update angle anims
	elseif jumpAnimTime <= 0 then -- Regular fall after jump window
		if not isAirDiving and pose ~= "Falling" then -- Don't interrupt airdive [cite: 64]
			playAnimation("fall", FALL_TRANSITION_TIME, Humanoid) -- [cite: 11, 64]
			pose = "Falling"
		end
	else -- Still in jump animation window
		pose = "Jumping" -- Remain in jump state
	end

end

function onFallingDown()
	-- This state implies physics are taking over (ragdolled)
	stopAllAnimations()
	stopToolAnimations()
	pose = "FallingDown"
end

function onSeated()
	stopAllAnimations() -- Stop movement/idle anims
	stopToolAnimations() -- Stop tool anims
	playAnimation("sit", 0.5, Humanoid) -- [cite: 12, 73]
	pose = "Seated"
end

function onPlatformStanding()
	-- Similar to idle, but on a moving platform
	if pose ~= "PlatformStanding" and emoteNames[currentAnim] == nil then
		playAnimation("idle", 0.1, Humanoid)
	end
	pose = "PlatformStanding"
end

function onSwimming(speed) -- R15 swimming state (not FE2 custom swim)
	-- This might conflict with FE2's custom swimming logic, potentially ignore or adapt.
	-- FE2 uses FreeFall state for its swimming logic
	-- Let's prioritize FE2 logic by having onFreeFall handle swim anims.
	-- print("Humanoid Swimming State, Speed:", speed)
	-- if speed > 0 then
	-- 	pose = "Running" -- Or a generic moving state
	-- else
	-- 	pose = "Standing" -- Or a generic idle state
	-- end
end

-- Main update loop (simplified from default's 'move') [cite: 11-13, 69-79]
function processMovement(deltaTime)
	-- Decrement jump timer
	if jumpAnimTime > 0 then
		jumpAnimTime = jumpAnimTime - deltaTime -- [cite: 71]
	end

	-- State checks that might override animations handled by Humanoid states
	if pose == "Seated" then
		-- Ensure sit animation is playing if somehow interrupted
		if currentAnim ~= "sit" then playAnimation("sit", 0.1, Humanoid) end -- [cite: 73]
		return -- No other logic needed when seated
	end

	-- Check Humanoid state if not handled by specific events
	local state = Humanoid:GetState()
	if state == Enum.HumanoidStateType.Running then
		onRunning(Humanoid.WalkSpeed) -- Use WalkSpeed as approximation if Running event didn't fire recently
	elseif state == Enum.HumanoidStateType.Idle and pose ~= "Standing" and pose ~= "PlatformStanding" and emoteNames[currentAnim] == nil then
		-- If idle state but pose isn't Standing/PlatformStanding, and not emoting, force idle
		if not isSwimming and not isSliding and not isSwinging and not isWallHanging then
			playAnimation("idle", 0.1, Humanoid)
			pose = "Standing"
		end
	elseif state == Enum.HumanoidStateType.Freefall then
		onFreeFall() -- Ensure falling/swimming logic is checked
	elseif state == Enum.HumanoidStateType.Jumping then
		-- Jump state might persist longer than animation, ensure fall starts if timer is up
		if jumpAnimTime <= 0 and not isSwimming and not isSliding and not isSwinging and not isWallHanging and not isAirDiving then
			if pose ~= "Falling" then playAnimation("fall", FALL_TRANSITION_TIME, Humanoid) end
			pose = "Falling"
		end
	end

	-- Handle Tool Animations
	animateTool() -- [cite: 78]
end

--[[ Event Connections --]]

-- Humanoid States [cite: 13, 79]
Humanoid.Died:Connect(onDied)
Humanoid.Running:Connect(onRunning)
Humanoid.Jumping:Connect(onJumping)
Humanoid.Climbing:Connect(onClimbing)
Humanoid.GettingUp:Connect(onGettingUp)
Humanoid.FreeFalling:Connect(onFreeFall)
Humanoid.FallingDown:Connect(onFallingDown)
Humanoid.Seated:Connect(onSeated)
Humanoid.PlatformStanding:Connect(onPlatformStanding)
Humanoid.Swimming:Connect(onSwimming) -- Might need careful handling due to FE2 custom swim

-- Chat Emotes [cite: 13, 81-83]
if Players.LocalPlayer and Players.LocalPlayer == Character:FindFirstAncestorWhichIsA("Player") then
	Players.LocalPlayer.Chatted:Connect(function(msg)
		local emote = ""
		msg = string.lower(msg)
		if msg == "/e dance" then
			emote = dances[math.random(1, #dances)] -- [cite: 82]
		elseif string.sub(msg, 1, 3) == "/e " then
			emote = string.sub(msg, 4) -- [cite: 82]
		elseif string.sub(msg, 1, 7) == "/emote " then
			emote = string.sub(msg, 8) -- [cite: 82]
		end

		if emote ~= "" then
			performEmote(emote, true) -- Pass true for chat command
		end
	end)
else
	-- warn("Could not connect chatted event: Not LocalPlayer's character or LocalPlayer not found.")
end


-- FE2 Custom Events

-- Swim Toggle [cite: 87]
ToggleSwimEvent.Event:Connect(function(enabled)
	if isSwimming ~= enabled then
		isSwimming = enabled
		if not isSwimming then
			-- Stop swim angle animations when exiting water
			updateSwimDir() -- This will stop tracks if isSwimming is false
			-- Re-evaluate state (likely falling or idle)
			onFreeFall() -- Check if falling
			if Humanoid:GetState() == Enum.HumanoidStateType.Idle then
				playAnimation("idle", 0.1, Humanoid)
				pose = "Standing"
			end
		else
			-- When entering water, immediately check state
			onFreeFall()
		end
	end
end)

-- Air Diving
AirDivingEvent.Event:Connect(function()
	isAirDiving = true
	playAnimation("airdive", 0, Humanoid)
	pose = "AirDiving"
	-- Need logic to exit AirDiving state, perhaps on landing or timeout?
	-- Example: Reset on landing
	local landedConn
	landedConn = Humanoid.StateChanged:Connect(function(old, new)
		if new == Enum.HumanoidStateType.Landed or new == Enum.HumanoidStateType.Running or new == Enum.HumanoidStateType.Idle then
			isAirDiving = false
			if landedConn then landedConn:Disconnect() end
			-- Play landing animation or transition to idle/run
			playAnimation("idle", 0.1, Humanoid)
			pose = "Standing"
		end
	end)
	-- Timeout safeguard
	delay(3, function() -- Exit after 3 seconds if still freefalling
		if isAirDiving and Humanoid:GetState() == Enum.HumanoidStateType.Freefall then
			isAirDiving = false
			if landedConn then landedConn:Disconnect() end
			onFreeFall() -- Transition to regular fall/swim
		end
	end)
end)

-- Sliding
SlidingEvent.Event:Connect(function(enabled)
	isSliding = enabled
	if isSliding then
		playAnimation("slide", 0.1, Humanoid)
		pose = "Sliding"
	else
		-- When stopping sliding, revert to appropriate state (likely idle/running/falling)
		if currentAnim == "slide" then
			local state = Humanoid:GetState()
			if state == Enum.HumanoidStateType.Running then
				playAnimation("walk", 0.1, Humanoid) -- Transition to walk
				pose = "Running"
				onRunning(Humanoid.WalkSpeed) -- Set speed
			elseif state == Enum.HumanoidStateType.Freefall then
				onFreeFall() -- Handle fall/swim logic
			else -- Default to idle
				playAnimation("idle", 0.1, Humanoid)
				pose = "Standing"
			end
		end
	end
end)

-- Wall Hang/Jump
WalljumpEvent.Event:Connect(function(enabled) -- Assuming event signals hanging state
	isWallHanging = enabled
	if isWallHanging then
		playAnimation("wallhang", 0, Humanoid)
		pose = "WallHanging"
	else
		-- When stopping wall hang, revert to appropriate state (likely falling/jumping)
		if currentAnim == "wallhang" then
			onFreeFall() -- Usually falling after letting go
		end
	end
end)

-- Swinging
SwingingEvent.Event:Connect(function(enabled)
	isSwinging = enabled
	if isSwinging then
		playAnimation("swing", 0, Humanoid)
		pose = "Swinging"
	else
		-- When stopping swing, revert to appropriate state (likely falling)
		if currentAnim == "swing" then
			onFreeFall()
		end
	end
end)

-- Update Custom Emote ID
UpdateEmoteEvent.OnClientEvent:Connect(function(newEmoteId)
	local animId = (newEmoteId and tonumber(newEmoteId)) or AnimIDs.Emote.Value -- Fallback to default if nil [cite: 92]
	animNames.customemote[1].id = "http://www.roblox.com/asset/?id=" .. animId
	configureAnimationSet("customemote", animNames.customemote) -- Reload the animation set [cite: 92]
end)

-- Update Animation Pack (Assumes attribute-based system like FE2)
UpdateAnimationsEvent.OnClientEvent:Connect(function(animPackInstance)
    --[[ Example structure - Adapt based on actual AnimPackInstance format
    if animPackInstance and animPackInstance:IsA("Instance") then
        for animName, defaultList in pairs(animNames) do
            local attributeValue = animPackInstance:GetAttribute(animName)
            if attributeValue and tonumber(attributeValue) then
                 local newId = "rbxassetid://" .. tostring(attributeValue)
                 -- Only overwrite if ID seems valid
                 if newId ~= animNames[animName][1].id then -- Check if changed
                    -- print("Updating animation:", animName, "to", newId)
                    local newList = { { id = newId, weight = 10 } } -- Create new list
                    configureAnimationSet(animName, newList) -- Reload with new ID list [cite: 94]
                 end
            else
                -- If attribute missing or invalid, ensure default is loaded
                configureAnimationSet(animName, defaultList) -- Reload default
            end
        end
    else -- Reset all to default if animPackInstance is nil
        -- print("Resetting all animations to default")
        for animName, defaultList in pairs(animNames) do
            configureAnimationSet(animName, defaultList)
        end
    end
    --]]
	--Simplified version just reloading based on AnimIDs folder if needed, or needs proper implementation
	for animName, defaultList in pairs(animNames) do
		configureAnimationSet(animName, defaultList) -- Reload based on current AnimID values
	end

end)

-- Custom Emote Fire [cite: 94]
EmoteFireEvent.Event:Connect(function()
	performEmote("customemote", false) -- Pass false as it's not a chat command
end)


-- FE2 Remote Function (Purpose unclear from decompiled code - maybe state sync?)
-- local remoteFunc = ReplicatedStorage:WaitForChild("Remote"):WaitForChild("ejZSTIQliqPRdUVZlWcZmaDGWapAAWxZ") -- Very specific name
-- remoteFunc.OnClientInvoke = function(param) -- [cite: 80]
--     -- u38 = param -- Decompiled variable u38, purpose unknown [cite: 80]
--     -- Example: maybe disables emotes?
--     -- if u38 then stopAllAnimations() end
--     return Humanoid, Humanoid:GetState() -- Return humanoid and state [cite: 80]
-- end

--[[ Initialization --]]

-- Wait for SwimVel instance [cite: 16]
swimVelocityInstance = HumanoidRootPart:WaitForChild("SwimVel", 10)
if not swimVelocityInstance then
	-- warn("SwimVel instance not found in HumanoidRootPart!")
else
	-- Connect swim velocity change
	swimVelocityInstance:GetPropertyChangedSignal("Velocity"):Connect(updateSwimDir)
end

-- Connect MoveDirection change [cite: 86]
Humanoid:GetPropertyChangedSignal("MoveDirection"):Connect(updateSwimDir)

-- Preload swim angle animations [cite: 83]
local swimAngleIDs = { -- From decompiled [cite: 16]
	"rbxassetid://" .. AnimIDs.SwimAngle90.Value,
	"rbxassetid://" .. AnimIDs.SwimAngle45.Value,
	"rbxassetid://" .. AnimIDs.SwimAngle0.Value,
	"rbxassetid://" .. AnimIDs["SwimAngle-45"].Value,
	"rbxassetid://" .. AnimIDs["SwimAngle-90"].Value
}
for i, animId in ipairs(swimAngleIDs) do
	local anim = Instance.new("Animation")
	anim.Name = "SwimAngle" .. i -- Give unique names
	anim.AnimationId = animId
	local track = Humanoid:LoadAnimation(anim) -- [cite: 83]
	track.Looped = true -- Angle animations should loop/hold
	track.Priority = Enum.AnimationPriority.Action -- High priority to override swim movement
	table.insert(swimAngleTracks, track)
end

-- Load all animation sets
for name, fileList in pairs(animNames) do
	configureAnimationSet(name, fileList)
end

-- Initialize state
playAnimation("idle", 0.1, Humanoid) -- [cite: 94]
pose = "Standing"

-- Main loop using RenderStepped for smoother updates [cite: 14, 94]
RunService.RenderStepped:Connect(function(deltaTime)
	if Character and Character.Parent and Humanoid and Humanoid.Health > 0 then
		processMovement(deltaTime)
	else
		-- Character removed or dead, disconnect? (optional)
		-- Could lead to issues if script is destroyed and recreated rapidly.
	end
end)

print("Custom FE2 Animate Script Loaded for", Character.Name)
